<h4>Graph</h4>
<p>Bag implementation,</p>
<pre>
  <code>
    {{gp}}
  </code>
</pre>
<hr>
<h4>Depth First Search</h4>
<p>From starting point (source) trace (recurcivly) if vertices has connection. The whole sub-group is marked.</p>
<pre>
  <code>
    {{dfs}}
  </code>
</pre>
<hr>
<h4>Depth First Path</h4>
<p>From starting point (source) find path to vertices that has connection. The path is not shortest!</p>
<pre>
  <code>
    {{dfp}}
  </code>
</pre>
<hr>
<h4>Breadth First Path</h4>
<p>From starting point (source) find path to vertices that has connection. The path is shortest! No weights! From source mark all adjecent vertices using queue.</p>
<pre>
  <code>
    {{bfp}}
  </code>
</pre>
<hr>
<h4>Symbol Graph</h4>
<p>Use of Symbol Table (Es6Map) for key/value connections. Keys coluld be Comparable (string). Graph is filled from file of rows having separated values. First value in row is connected to others. Adjecent graph find connectons both ways (firs/others and other/first).</p>
<pre>
  <code>
    {{ses6}}
  </code>
</pre>
<hr>

<hr>
<h4>Directed Graph</h4>
<p>Bag implementation.</p>
<pre>
  <code>
    {{dg}}
  </code>
</pre>
<hr>
<h4>Directed Depth First Search</h4>
<p>Use of DirectedGraph. Only check connectivity. Mark group from source.</p>
<pre>
  <code>
    {{ddfs}}
  </code>
</pre>
<hr>
<h4>Depth First Order</h4>
<p>Traverse graph and sort vertices in topological order! Should check for cycle. This is Shedule task!</p>
<pre>
  <code>
    {{dfo}}
  </code>
</pre>
<hr>
<h4>Strong Connected components in Directed Graph</h4>
<p>Find cycles of vertices in all. Check if two vertices are strongly connected.</p>
<pre>
  <code>
    {{sc}}
  </code>
</pre>
<hr>
<h4>Prinm's Minimum Spanning Tree (Lazy)</h4>
<p>Extract sub tree of minimum weighted paths. Add next vertice to the tree using Priority Queue(min 1,2,3..) put all adjesent edjes in PQ and get min that is shortest. Do not connect already marked edges.</p>
<pre>
  <code>
    {{primMST}}
  </code>
</pre>
<hr>
<h4>Kruskal Minimum Spanning Tree</h4>
<p>Extract sub tree of minimum weighted paths. Sort all edges by weight (MinPQ) and connect one by one it chaeck if already connected using Union Find. Slower than Prim.</p>
<pre>
  <code>
    {{kr}}
  </code>
</pre>
<hr>
<h4>Directed graph shortest path Dijkstra</h4>
<p>Find shortest path. From source fallow all paths and accumulate weight with every next vertice. Compare weights to vertix and new path. Use IndexedMinPQ to get smallest weights first. Show shortest path back tracking from destination to source edges.</p>
<pre>
  <code>
    {{dgsp}}
  </code>
</pre>
<hr>
<h4>Directed graph shortest path Acyclic</h4>
<p>Check for cyclic. Relax edges in topological order every edge is relaxed exactly once. calculate every path and replace with shortest.</p>
<pre>
  <code>
    {{acyclic}}
  </code>
</pre>
<hr>
<h4>Schedule parallel jobs Acyclic</h4>
<p>Search longest path of paralel jobs. Use of Longest Path Acyclic algoritm.</p>
<pre>
  <code>
    {{pschedule}}
  </code>
</pre>
<hr>
<h4>Shortest path cyclic negative weights Bellman-Ford</h4>
<p>Negative weights could lead to infinity loop. Counter track passes to prevent that.</p>
<pre>
  <code>
    {{spBF}}
  </code>
</pre>
<hr>
<h4>Arbitrage - find negative cycle</h4>
<p>Replace each weight by its logarithm, negated. With this change, computing path weights by multiplying edge weights in the original problem corresponds to adding them in the transformed problem. </p>
<pre>
  <code>
    {{arbit}}
  </code>
</pre>
<hr>